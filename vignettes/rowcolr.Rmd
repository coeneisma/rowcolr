---
title: "rowcolr"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{rowcolr}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(rowcolr)
```


## Usage

The primary function of `rowcolr` is `extract_values()`, which allows you to extract structured data from Excel files based on row and column label patterns.

The package can be loaded with:

```{r}
library(rowcolr)
```


### Example: Extracting Data from an Excel File


```{r}
# Extract values from an Excel file using default row/column regex patterns
dataset <- extract_values(rowcolr_example("example.xlsx"))

head(dataset |> 
       dplyr::select(-c(filename, sheet, row, col)))
```


### Example: Using Specific Row and Column Identifiers

If you have predefined row or column labels, you can use them directly by providing a character vector.

```{r}
data("row_identifiers_example")
row_identifiers_example
```

```{r}
data("col_identifiers_example")
col_identifiers_example
```

These vectors can be used with the `col_identifiers` and `row_identifiers` arguments:

```{r}
dataset <- extract_values(rowcolr_example("example.xlsx"), 
                          col_identifiers = col_identifiers_example,
                          row_identifiers = row_identifiers_example)

head(dataset |> 
       dplyr::select(-c(filename, sheet, row, col)))
```

### Example: (not) Cleaning Descriptions by Removing Suffix Patterns

By default, row and column labels are cleaned of their identified suffix before combining them into the description. To disable this use `clean_description = FALSE`

```{r}
dataset <- extract_values(rowcolr_example("example.xlsx"), 
                          clean_description = FALSE)

head(dataset |> 
       dplyr::select(-c(filename, sheet, row, col)))
```

## Conclusion

The `rowcolr` package is a powerful tool for extracting structured data from Excel files based on customizable row and column patterns. It is designed to be flexible, allowing for both regex-based matching and predefined lists of identifiers.
